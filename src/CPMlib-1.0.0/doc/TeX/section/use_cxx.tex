\section{C++ユーザープログラムでの利用方法}
\label{use_cxx}
以下に，CPMライブラリのC++ APIの説明を示します．


\subsection{サンプルプログラム}

Examples/c++ディレクトリに，C++ユーザープログラムでのCPMライブラリ使用例の
サンプルソースコードが収められています．

\begin{itemize}
\item[・] {\tt main.C} \\
領域分割情報ファイルの読み込み，領域分割実行，各種通信処理のテストを行うサンプルです．\\
このサンプルコードはmake時に一緒にコンパイル，リンクされ，{\tt exampleCXX}という
実行ファイルが作成されます．{\tt data}ディレクトリに実行サンプルが収められています．
\end{itemize}


\subsection{cpm\_ParaManager.hのインクルード}

CPMライブラリのC++ API関数群は，CPMライブラリが提供するヘッダファイル
cpm\_ParaManager.hで定義されています．
CPMライブラリのAPI関数を使う場合は，このヘッダーファイルをインクルードします．

cpm\_ParaManager.hには，ユーザーが利用可能な本ライブラリのAPIがまとめられている
cpm\_ParaManagerクラスのインターフェイスが記述されています．ユーザープログラムから
本ライブラリを使用する場合，このクラスのメソッドを用います．

cpm\_ParaManager.hは，configureスクリプト実行時の設定{\tt prefix}
配下の{\tt \$\{prefix\}}/includeに{\tt make install}時にインストールされます．\\


\subsection{cpm\_TextParserDomain.hのインクルード}

CPMライブラリは，領域分割情報の生成，管理，各種通信機能等の他に，TextParserライブラリ
フォーマットの領域分割情報ファイルの読み込み機能を提供しています．
読み込んだ領域分割情報をCPMライブラリの領域分割処理にそのまま渡すことで，領域分割処理を
行うことができます．

領域分割情報ファイルの読み込み機能を利用するためには，cpm\_TextParserDomain.hを
インクルードします．
cpm\_TextParserDomain.hには，領域分割情報ファイルの読み込み処理が記述されています．


\subsection{マクロ，列挙型，エラーコード}

CPMライブラリ内で使用されるマクロ，列挙型，エラーコードについては，
cpm\_Define.hに定義されています．


\begin{itemize}
\item[・] {REAL\_TYPEマクロ}

REAL\_TYPEマクロは，cpm\_Define.hで表\ref{tbl:FaceFlag}のように定義されています．\\
configure時の{\tt --with-real}オプションの指定に従い，REAL\_TYPE型をfloat/doubleの
いずれかに設定しています．\\

\begin{table}[htb]
\begin{center}
\caption{REAL\_TYPEマクロ}
\label{tbl:realtype}
\begin{tabular}{|c|l|}
\hline 
{\tt --with-real}オプション & 定義\\
\hline
指定無し & \#define REAL\_TYPE float \\
{\tt --with-real=float} & \#define REAL\_TYPE float \\
{\tt --with-real=double} & \#define REAL\_TYPE double \\
\hline   
\end{tabular}
\end{center}
\end{table}


\item[・] {cpm\_FaceFlag列挙型}

cpm\_FaceFlag列挙型は，cpm\_Define.hで表\ref{tbl:FaceFlag}のように定義されています．\\
CPMライブラリから取得した隣接領域番号配列等の6wordの配列を参照する際の，
配列インデクスの定義です．\\

\begin{table}[htb]
\begin{center}
\caption{cpm\_FaceFlag列挙型}
\label{tbl:FaceFlag}
\begin{tabular}{|c|c|l|}
\hline 
cpm\_FaceFlag要素 & 値 & 意味\\
\hline
X\_MINUS & 0 & -X面\\
Y\_MINUS & 1 & -Y面\\
Z\_MINUS & 2 & -Z面\\
X\_PLUS  & 3 & +X面\\
Y\_PLUS  & 4 & +Y面\\
Z\_PLUS  & 5 & +Z面\\
\hline
\end{tabular}
\end{center}
\end{table}


\item[・] {cpm\_DirFlag列挙型}

cpm\_DirFlag列挙型は，cpm\_Define.hで表\ref{tbl:DirFlag}のように定義されています．\\
CPMライブラリから取得したVOXEL数配列等の3wordの配列を参照する際の，配列インデクスの定義です．
また，周期境界通信関数の周期境界方向を指定するフラグとしても使われます．\\

\begin{table}[htb]
\begin{center}
\caption{cpm\_DirFlag列挙型}
\label{tbl:DirFlag}
\begin{tabular}{|c|c|l|}
\hline 
cpm\_DirFlag要素 & 値 & 意味\\
\hline
X\_DIR & 0 & X方向\\
Y\_DIR & 1 & Y方向\\
Z\_DIR & 2 & Z方向\\
\hline
\end{tabular}
\end{center}
\end{table}


\item[・] {cpm\_PMFlag列挙型}

cpm\_PMFlag列挙型は，cpm\_Define.hで表\ref{tbl:PMFlag}のように定義されています．\\
周期境界通信関数の周期境界方向を指定するフラグとして使われます．\\

\begin{table}[htb]
\begin{center}
\caption{cpm\_PMFlag列挙型}
\label{tbl:PMFlag}
\begin{tabular}{|c|c|l|}
\hline 
cpm\_PMFlag要素 & 値 & 意味\\
\hline
PLUS2MINUS & 0 & +側から-側\\
MINUS2PLUS & 1 & -側から+側\\
BOTH       & 2 & 双方向\\
\hline
\end{tabular}
\end{center}
\end{table}


\item[・] {cpm\_ErrorCode列挙型}

cpm\_ErrorCode列挙型は，cpm\_Define.hで表\ref{tbl:ErrorCode1}，\ref{tbl:ErrorCode2}の
ように定義されています．\\
CPMライブラリのAPI関数のエラーコードは，全てこの列挙型で定義されています．
Fortan90インターフェイスのエラーコードにも，この列挙型の値（整数値）がセットされます．\\

\begin{table}[htb]
\begin{center}
\caption{cpm\_ErrorCode列挙型 その1}
\label{tbl:ErrorCode1}
\footnotesize
\begin{tabular}{|c|c|l|}
\hline 
cpm\_ErrorCode要素 & 値 & 意味\\
\hline
CPM\_SUCCESS                        & 0    & 正常終了\\
CPM\_ERROR                          & 1000 & その他のエラー\\
CPM\_ERROR\_INVALID\_PTR            & 1002 & ポインタのエラー\\
CPM\_ERROR\_INVALID\_DOMAIN\_NO     & 1003 & 領域番号が不正\\
CPM\_ERROR\_INVALID\_OBJKEY         & 1004 & 指定登録番号のオブジェクトが存在しない\\
CPM\_ERROR\_REGIST\_OBJKEY          & 1005 & オブジェクト登録に失敗\\
CPM\_ERROR\_TEXTPARSER              & 2000 & テキストパーサーに関するエラー\\
CPM\_ERROR\_NO\_TEXTPARSER          & 2001 & テキストパーサーを組み込んでいない\\
CPM\_ERROR\_TP\_INVALID\_G\_ORG     & 2004 & 領域分割情報ファイルのドメイン原点情報が不正\\
CPM\_ERROR\_TP\_INVALID\_G\_VOXEL   & 2005 & 領域分割情報ファイルのドメインVOXEL数情報が不正\\
CPM\_ERROR\_TP\_INVALID\_G\_PITCH   & 2006 & 領域分割情報ファイルのドメインピッチ情報が不正\\
CPM\_ERROR\_TP\_INVALID\_G\_RGN     & 2007 & 領域分割情報ファイルのドメイン空間サイズ情報が不正\\
CPM\_ERROR\_TP\_INVALID\_G\_DIV     & 2008 & 領域分割情報ファイルのドメイン領域分割数情報が不正\\
CPM\_ERROR\_TP\_INVALID\_POS        & 2009 & 領域分割情報ファイルのサブドメイン位置情報が不正\\
CPM\_ERROR\_TP\_INVALID\_BCID       & 2010 & 領域分割情報ファイルのサブドメインBCID情報が不正\\
CPM\_ERROR\_VOXELINIT               & 3000 & VoxelInitでエラー\\
CPM\_ERROR\_NOT\_IN\_PROCGROUP      & 3001 & 自ランクがプロセスグループに含まれていない\\
CPM\_ERROR\_ALREADY\_VOXELINIIT     & 3002 & 指定されたプロセスグループが既に領域分割済み\\
CPM\_ERROR\_MISMATCH\_NP\_SUBDOMAIN & 3003 & 並列数とサブドメイン数が一致していない\\
CPM\_ERROR\_CREATE\_RANKMAP         & 3004 & ランクマップ生成に失敗\\
CPM\_ERROR\_CREATE\_NEIGHBOR        & 3005 & 隣接ランク情報生成に失敗\\
CPM\_ERROR\_CREATE\_LOCALDOMAIN     & 3006 & ローカル領域情報生成に失敗\\
CPM\_ERROR\_INSERT\_VOXELMAP        & 3007 & 領域情報のマップへの登録失敗\\
CPM\_ERROR\_CREATE\_PROCGROUP       & 3008 & プロセスグループ生成に失敗\\
CPM\_ERROR\_INVALID\_VOXELSIZE      & 3009 & VOXEL数が不正\\
CPM\_ERROR\_GET\_INFO               & 4000 & 情報取得系関数でエラー\\
CPM\_ERROR\_GET\_DIVNUM             & 4001 & 領域分割数の取得エラー\\
CPM\_ERROR\_GET\_PITCH              & 4002 & ピッチの取得エラー\\
CPM\_ERROR\_GET\_GLOBALVOXELSIZE    & 4003 & 全体ボクセル数の取得エラー\\
CPM\_ERROR\_GET\_GLOBALORIGIN       & 4004 & 全体空間の原点の取得エラー\\
CPM\_ERROR\_GET\_GLOBALREGION       & 4005 & 全体空間サイズの取得エラー\\
CPM\_ERROR\_GET\_LOCALVOXELSIZE     & 4006 & 自ランクのボクセル数の取得エラー\\
CPM\_ERROR\_GET\_LOCALORIGIN        & 4007 & 自ランクの空間原点の取得エラー\\
CPM\_ERROR\_GET\_LOCALREGION        & 4008 & 自ランクの空間サイズの取得エラー\\
CPM\_ERROR\_GET\_DIVPOS             & 4009 & 自ランクの領域分割位置の取得エラー\\
CPM\_ERROR\_GET\_BCID               & 4010 & 自ランクのBCIDの取得エラー\\
CPM\_ERROR\_GET\_HEADINDEX          & 4011 & 始点インデクスの取得エラー\\
CPM\_ERROR\_GET\_TAILINDEX          & 4012 & 終点インデクスの取得エラー\\
CPM\_ERROR\_GET\_NEIGHBOR\_RANK     & 4013 & 隣接ランク番号の取得エラー\\
CPM\_ERROR\_GET\_PERIODIC\_RANK     & 4014 & 周期境界位置の隣接ランク番号の取得エラー\\
CPM\_ERROR\_GET\_MYRANK             & 4015 & ランク番号の取得エラー\\
CPM\_ERROR\_GET\_NUMRANK            & 4016 & ランク数の取得エラー\\
\hline
\end{tabular}
\end{center}
\end{table}

\begin{table}[htb]
\begin{center}
\caption{cpm\_ErrorCode列挙型 その2}
\label{tbl:ErrorCode2}
\footnotesize
\begin{tabular}{|c|c|l|}
\hline 
cpm\_ErrorCode要素 & 値 & 意味\\
\hline
CPM\_ERROR\_MPI                     & 9000 & MPIのエラー\\
CPM\_ERROR\_NO\_MPI\_INIT           & 9001 & MPI\_Initがコールされていない\\
CPM\_ERROR\_MPI\_BARRIER            & 9003 & MPI\_Barrierでエラー\\
CPM\_ERROR\_MPI\_BCAST              & 9004 & MPI\_Bcastでエラー\\
CPM\_ERROR\_MPI\_SEND               & 9005 & MPI\_Sendでエラー\\
CPM\_ERROR\_MPI\_RECV               & 9006 & MPI\_Recvでエラー\\
CPM\_ERROR\_MPI\_ISEND              & 9007 & MPI\_Isendでエラー\\
CPM\_ERROR\_MPI\_IRECV              & 9008 & MPI\_Irecvでエラー\\
CPM\_ERROR\_MPI\_WAIT               & 9009 & MPI\_Waitでエラー\\
CPM\_ERROR\_MPI\_WAITALL            & 9010 & MPI\_Waitallでエラー\\
CPM\_ERROR\_MPI\_ALLREDUCE          & 9011 & MPI\_Allreduceでエラー\\
CPM\_ERROR\_MPI\_GATHER             & 9012 & MPI\_Gatherでエラー\\
CPM\_ERROR\_MPI\_ALLGATHER          & 9013 & MPI\_Allgatherでエラー\\
CPM\_ERROR\_MPI\_GATHERV            & 9014 & MPI\_Gathervでエラー\\
CPM\_ERROR\_MPI\_ALLGATHERV         & 9015 & MPI\_Allgathervでエラー\\
CPM\_ERROR\_MPI\_DIMSCREATE         & 9016 & MPI\_Dims\_createでエラー\\
CPM\_ERROR\_BNDCOMM                 & 9500 & BndCommでエラー\\
CPM\_ERROR\_BNDCOMM\_VOXELSIZE      & 9501 & VoxelSize取得でエラー\\
CPM\_ERROR\_BNDCOMM\_BUFFER         & 9502 & 袖通信バッファ取得でエラー\\
CPM\_ERROR\_BNDCOMM\_BUFFERLENGTH   & 9503 & 袖通信バッファサイズが足りない\\
CPM\_ERROR\_PERIODIC                & 9600 & PeriodicCommでエラー\\
CPM\_ERROR\_PERIODIC\_INVALID\_DIR  & 9601 & 不正な軸方向フラグが指定された\\
CPM\_ERROR\_PERIODIC\_INVALID\_PM   & 9602 & 不正な正負方向フラグが指定された\\
CPM\_ERROR\_MPI\_INVALID\_COMM      & 9100 & MPIコミュニケータが不正\\
CPM\_ERROR\_MPI\_INVALID\_DATATYPE  & 9101 & 対応しない型が指定された\\
CPM\_ERROR\_MPI\_INVALID\_OPERATOR  & 9102 & 対応しないオペレータが指定された\\
CPM\_ERROR\_MPI\_INVALID\_REQUEST   & 9103 & 不正なリクエストが指定された\\
\hline
\end{tabular}
\end{center}
\end{table}
\end{itemize}


\clearpage


\subsection{インスタンスの取得}
\label{CPMinstance}

cpm\_ParaManagerクラスのインスタンスは，Singletonパターンによって
プログラム内でただ1つ生成されます．
そのインスタンスへのポインタを取得するメソッドは，引数の違いによる複数のメソッドが
用意されており，cpm\_ParaManager.h 内で次のように定義されています．\\

\begin{spacing}{0.8}
\begin{itembox}[l]{インスタンスの生成，インスタンスへのポインタの取得}
{\tt
\begin{verbatim}
static cpm_ParaManager* cpm_ParaManager::get_instance(); 
\end{verbatim}
}
唯一のcpm\_ParaManagerクラスのインスタンスへのポインタを取得します．
\begin{description}
\item[戻り値] 唯一のcpm\_ParaManagerクラスのインスタンスへのポインタ
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{インスタンスの生成，インスタンスへのポインタの取得（MPI\_Initも実行）}
{\tt
\begin{verbatim}
static cpm_ParaManager*
cpm_ParaManager::get_instance(int &argc, char**& argv);
\end{verbatim}
}
唯一のcpm\_ParaManagerクラスのインスタンスへのポインタを取得する．\\
main関数の引数を渡すことで，MPI\_Initが未実行の場合に，インスタンス生成と同時に
MPI\_Initも実行する．また，\ref{CPMinit}章のCPMライブラリ初期化処理も
実行する．
\begin{description}
\item[{\tt argc[{\it input}]}] main関数の第1引数
\item[{\tt argv[{\it input}]}] main関数の第2引数
\\
\item[戻り値] 唯一のcpm\_ParaManagerクラスのインスタンスへのポインタ
\end{description}
\end{itembox}\\
\end{spacing}

ユーザーの作成するプログラム内では，このメソッドで得られたインスタンスへの
ポインタを用いて，各メンバ関数へアクセスします．


\clearpage


\subsection{CPMライブラリ初期化処理}
\label{CPMinit}

CPMライブラリを利用する上で，プログラムの先頭で1回だけ初期化メソッドを呼び出す必要があります．
初期化処理を行うメソッドは，引数の違いによる複数のメソッドが用意されており，
cpm\_ParaManager.h 内で次のように定義されています．\\

\begin{spacing}{0.8}
\begin{itembox}[l]{CPMライブラリ初期化処理}
{\tt
\begin{verbatim}
cpm_ErrorCode cpm_ParaManager::Initialize();
\end{verbatim}
}
CPMライブラリ初期化処理を行う．\\
この関数をコールする前に，MPI\_Initがコールされている必要がある．
\begin{description}
\item[戻り値] エラーコード（表\ref{tbl:ErrorCode1}，\ref{tbl:ErrorCode2}を参照）
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{CPMライブラリ初期化処理}
{\tt
\begin{verbatim}
cpm_ErrorCode cpm_ParaManager::Initialize(int &argc, char**& argv);
\end{verbatim}
}
CPMライブラリ初期化処理を行う．\\
main関数の引数を渡すことで，MPI\_Initが未実行の場合に，メソッド内部でMPI\_Initを
呼び出してから初期化処理を行う．
\begin{description}
\item[{\tt argc[{\it input}]}] main関数の第1引数
\item[{\tt argv[{\it input}]}] main関数の第2引数
\\
\item[戻り値] エラーコード（表\ref{tbl:ErrorCode1}，\ref{tbl:ErrorCode2}を参照）
\end{description}
\end{itembox}\\
\end{spacing}

CPMライブラリを利用するC++プログラムでは，main関数の先頭で\ref{CPMinstance}章，
\ref{CPMinit}章で示す，インスタンス取得と初期化処理を行う必要があります．
\par
API関数では，それぞれ引数有り/無しの関数が用意されていますが，以下の組み合わせで
使用してください．

\begin{spacing}{0.8}
\begin{itemize}
\item[・] {パターン1}\\
MPI\_Init(argc, argv);\\
cpm\_ParaManager *paraMngr = cpm\_ParaManager::get\_instance();\\
paraMngr-\verb|>|Initialize();\\
\item[・] {パターン2}\\
cpm\_ParaManager *paraMngr = cpm\_ParaManager::get\_instance();\\
paraMngr-\verb|>|Initialize(argc, argv);\\
\item[・] {パターン3}\\
cpm\_ParaManager *paraMngr = cpm\_ParaManager::get\_instance(argc, argv);\\
\end{itemize}
\end{spacing}


\clearpage


\subsection{領域分割情報ファイルの読み込み}
CPMライブラリでは，TextParserライブラリを用いた領域分割情報ファイルの読み込みを
サポートしています．

領域分割情報ファイルは，TextParserライブラリがサポートする書式で規定された，
領域分割数や空間サイズを記述したテキスト形式ファイルです．
（詳細は，\ref{domInfoFile}章を参照してください）

領域分割情報ファイルの読み込み処理を行うメソッドは，cpm\_TextParserDomain.h内で
次のように定義されています．\\

\begin{spacing}{0.8}
\begin{itembox}[l]{領域分割情報ファイルの読み込み}
{\tt
\begin{verbatim}
static cpm_GlobalDomainInfo*
cpm_TextParserDomain::Read( std::string filename, int &errorcode );
\end{verbatim}
}
領域分割情報ファイルの読み込みを行う．\\
取得した領域情報のポインタは，\ref{voxelInit}章の領域分割処理にそのまま渡すことが可能．
領域分割情報ファイルを利用する場合，実行時の並列数（MPIプロセス並列数）は，活性サブドメイン数
以上である必要がある．

\begin{description}
\item[{\tt filename[{\it input}]}] 領域分割情報ファイル名
\item[{\tt errorcode[{\it output}]}] エラーコード（表\ref{tbl:ErrorCode1}，
\ref{tbl:ErrorCode2}を参照）
\\
\item[戻り値] 領域情報のポインタ
\end{description}
\end{itembox}\\
\end{spacing}

\begin{itemize}
\item[（注）] 取得した領域情報のポインタは，不要になった時（VoxelInit実行後など）に
ユーザーがdeleteする必要があります．
\begin{verbatim}
  // 領域分割情報ファイルの読み込み
  cpm_GlobalDomainInfo* dInfo = cpm_TextParserDomain::Read( fname, err );
        :
     （処理）
        :
  // 不要になったのでdelete
  delete dInfo;
\end{verbatim}
\end{itemize}


\clearpage


\subsection{プロセスグループ}
\label{procGrp}
CPMライブラリの領域情報管理には，プロセスグループの概念があります．

プロセスグループを使用することで，複数の計算空間を同時に扱うことができます．
プロセスグループはCPMライブラリ内部で番号で管理されています．
初期化後に，全ランクを含むデフォルトのプロセスグループが生成されており，
そのプロセスグループ番号は0に規定されています．
あるプロセスグループに対する処理を行う場合は，API関数にプロセスグループ番号を指定して
呼び出します．API関数に指定するプロセスグループ番号は省略可能となっており，
省略した場合はデフォルトのプロセスグループ番号0に対する処理を行います．

デフォルトでは無い，新規のプロセスグループを作成する場合は，cpm\_ParaManager.h内で
次のように定義されているAPIメソッドを使用します．\\

\begin{spacing}{0.8}
\begin{itembox}[l]{プロセスグループの作成}
{\tt
\begin{verbatim}
int cpm_ParaManager::CreateProcessGroup( int nproc, int *proclist
                                       , int parentProcGrpNo=0 );
\end{verbatim}
}
指定されたランクリストを使用してプロセスグループを生成する．

\begin{description}
\item[{\tt nproc[{\it input}]}] 生成するプロセスグループのランク数
\item[{\tt proclist[{\it input}]}] 生成するプロセスグループに含むランク番号の配列（サイズ:nproc）
\item[{\tt parentProcGrpNo[{\it input}]}] 親とするプロセスグループの番号（省略時0）
\\
\item[戻り値] 0以上:生成されたプロセスグループの番号，負値:エラー
\end{description}
\end{itembox}\\
\end{spacing}


\clearpage


\subsection{領域分割処理}
\label{voxelInit}
領域分割処理を行うメソッドは，引数の違いによる複数のメソッドが
用意されており，cpm\_ParaManager.h 内で次のように定義されています\\

\begin{spacing}{0.8}
\begin{itembox}[l]{領域分割処理}
{\tt
\begin{verbatim}
cpm_ErrorCode
cpm_ParaManager::VoxelInit( cpm_GlobalDomainInfo* domainInfo
                          , size_t maxVC=1, size_t maxN=3
                          , int procGrpNo=0 );
\end{verbatim}
}
領域分割処理を行う．\\
領域情報のポインタを渡すことで，領域分割情報ファイルで定義された領域情報と
活性サブドメイン情報を用いた領域分割を行う．\\
領域分割情報の活性サブドメイン数と，procGrpNoで指定されたランク数が
一致している必要がある．
\begin{description}
\item[{\tt domainInfo[{\it input}]}] 領域情報のポインタ
\item[{\tt maxVC[{\it input}]}] 袖通信バッファ確保用の最大袖層数
\item[{\tt maxN[{\it input}]}] 袖通信バッファ確保用の最大成分数
\item[{\tt procGrpNo[{\it input}]}] 領域分割を行うプロセスグループの番号
\\
\item[戻り値] エラーコード（表\ref{tbl:ErrorCode1}，\ref{tbl:ErrorCode2}を参照）
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{領域分割処理}
{\tt
\begin{verbatim}
cpm_ErrorCode
cpm_ParaManager::VoxelInit( int div[3], int vox[3], REAL_TYPE origin[3]
                          , REAL_TYPE pitch[3], int obcid[6]
                          , size_t maxVC=1, size_t maxN=3
                          , int procGrpNo=0 );
\end{verbatim}
}
領域分割処理を行う．\\
引数で指定したX,Y,Z方向の領域分割数，VOXEL数，空間原点座標，VOXELピッチ，
外部境界の境界条件IDを用いた領域分割を行う．\\
領域分割数と，procGrpNoで指定されたランク数が一致している必要があり，
このメソッドを用いて領域分割を行った場合，全てのサブドメインが活性サブドメインとなる．
\begin{description}
\item[{\tt div[{\it input}]}] X,Y,Z方向の領域分割数（3wordの配列，表\ref{tbl:DirFlag}参照）
\item[{\tt vox[{\it input}]}] X,Y,Z方向の全体VOXEL数（3wordの配列，表\ref{tbl:DirFlag}参照）
\item[{\tt origin[{\it input}]}] X,Y,Z方向の全体空間原点座標（3wordの配列，表\ref{tbl:DirFlag}参照）
\item[{\tt pitch[{\it input}]}] X,Y,Z方向のVOXELピッチ（3wordの配列，表\ref{tbl:DirFlag}参照）
\item[{\tt obcid[{\it input}]}] 外部境界名（6面）の境界条件ID配列（6wordの配列，表\ref{tbl:FaceFlag}参照）
\item[{\tt maxVC[{\it input}]}] 袖通信バッファ確保用の最大袖層数
\item[{\tt maxN[{\it input}]}] 袖通信バッファ確保用の最大成分数
\item[{\tt procGrpNo[{\it input}]}] 領域分割を行うプロセスグループの番号
\\
\item[戻り値] エラーコード（表\ref{tbl:ErrorCode1}，\ref{tbl:ErrorCode2}を参照）
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{領域分割処理}
{\tt
\begin{verbatim}
cpm_ErrorCode
cpm_ParaManager::VoxelInit( int vox[3], REAL_TYPE origin[3]
                          , REAL_TYPE pitch[3], int obcid[6]
                          , size_t maxVC=1, size_t maxN=3
                          , int procGrpNo=0 );
\end{verbatim}
}
領域分割処理を行う．\\
指定したプロセスグループのランク数で，自動的に領域分割数を決定し，
引数で指定したX,Y,Z方向のVOXEL数，空間原点座標，VOXELピッチ，外部境界の
境界条件IDを用いた領域分割を行う．\\
このメソッドを用いて領域分割を行った場合，全てのサブドメインが活性サブドメインとなる．\\
領域分割数は，隣接領域間の袖通信点数の総数が最小値になるような最適な分割数となる．
\begin{description}
\item[{\tt vox[{\it input}]}] X,Y,Z方向の全体VOXEL数（3wordの配列，表\ref{tbl:DirFlag}参照）
\item[{\tt origin[{\it input}]}] X,Y,Z方向の全体空間原点座標（3wordの配列，表\ref{tbl:DirFlag}参照）
\item[{\tt pitch[{\it input}]}] X,Y,Z方向のVOXELピッチ（3wordの配列，表\ref{tbl:DirFlag}参照）
\item[{\tt obcid[{\it input}]}] 外部境界名（6面）の境界条件ID配列（6wordの配列，表\ref{tbl:FaceFlag}参照）
\item[{\tt maxVC[{\it input}]}] 袖通信バッファ確保用の最大袖層数
\item[{\tt maxN[{\it input}]}] 袖通信バッファ確保用の最大成分数
\item[{\tt procGrpNo[{\it input}]}] 領域分割を行うプロセスグループの番号
\\
\item[戻り値] エラーコード（表\ref{tbl:ErrorCode1}，\ref{tbl:ErrorCode2}を参照）
\end{description}
\end{itembox}\\
\end{spacing}


\clearpage


\subsection{並列情報の取得}
\label{paraInfo}
並列関連の各種情報の取得関数は，cpm\_ParaManager.h 内で次のように定義されています．\\

\begin{spacing}{0.8}
\begin{itembox}[l]{並列実行であるかチェックする}
{\tt
\begin{verbatim}
bool cpm_ParaManager::IsParallel();
\end{verbatim}
}
並列実行であるかチェックする．\\
mpirun等で実行していても，並列数が1のときはfalseを返す．
\begin{description}
\item[戻り値] true:並列実行，false:逐次実行
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{ランク数の取得}
{\tt
\begin{verbatim}
int cpm_ParaManager::GetNumRank( int procGrpNo=0 );
\end{verbatim}
}
指定したプロセスグループのランク数を取得する．
\begin{description}
\item[{\tt procGrpNo[{\it input}]}] プロセスグループ番号（省略時0）
\\
\item[戻り値] ランク数
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{ランク番号の取得}
{\tt
\begin{verbatim}
int cpm_ParaManager::GetMyRankID( int procGrpNo=0 );
\end{verbatim}
}
指定したプロセスグループ内の自分自身のランク番号を取得する．
\begin{description}
\item[{\tt procGrpNo[{\it input}]}] プロセスグループ番号（省略時0）
\\
\item[戻り値] ランク番号
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{NULLのランク番号を取得}
{\tt
\begin{verbatim}
static int cpm_Base::getRankNull();
\end{verbatim}
}
NULLのランク番号を取得する．
\begin{description}
\item[戻り値] MPI\_PROC\_NULL
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{NULLのランクかどうかを確認}
{\tt
\begin{verbatim}
static bool cpm_Base::IsRankNull( int rankNo );
\end{verbatim}
}
NULLのランクかどうかを確認する．
無効なランク番号（負値）のとき，trueを返す．
\begin{description}
\item[{\tt rankNo[{\it input}]}] ランク番号
\\
\item[戻り値] true:NULL，false:有効なランク番号
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{MPIコミュニケータの取得}
{\tt
\begin{verbatim}
MPI_Comm cpm_ParaManager::GetMPI_Comm( int procGrpNo=0 );
\end{verbatim}
}
指定したプロセスグループのMPIコミュニケータを取得する．\\
ユーザーがMPI関数を用いた独自処理を記述する場合に，本メソッドを用いて，
プロセスグループに関連付けされたMPI\_Commを取得する．
\begin{description}
\item[{\tt procGrpNo[{\it input}]}] プロセスグループ番号（省略時0）
\\
\item[戻り値] MPIコミュニケータ
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{NULLのMPIコミュニケータを取得}
{\tt
\begin{verbatim}
static MPI_Comm cpm_Base::getCommNull();
\end{verbatim}
}
NULLのMPIコミュニケータを取得する．
\begin{description}
\item[戻り値] MPI\_COMM\_NULL
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{NULLのMPIコミュニケータかどうかを確認}
{\tt
\begin{verbatim}
static bool cpm_Base::IsCommNull( MPI_Comm comm );
\end{verbatim}
}
NULLのMPIコミュニケータかどうかを確認する．
無効なMPIコミュニケータ（MPI\_COMM\_NULL）のとき，trueを返す．
\begin{description}
\item[{\tt rankNo[{\it input}]}] ランク番号
\\
\item[戻り値] true:NULL，false:有効なMPIコミュニケータ
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{領域分割数の取得}
{\tt
\begin{verbatim}
const int* cpm_ParaManager::GetDivNum( int procGrpNo=0 );
\end{verbatim}
}
指定したプロセスグループの領域分割数を取得する．
\begin{description}
\item[{\tt procGrpNo[{\it input}]}] プロセスグループ番号（省略時0）
\\
\item[戻り値] 領域分割数配列のポインタ（3wordの配列，表\ref{tbl:DirFlag}参照）
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{自ランクの領域分割位置を取得}
{\tt
\begin{verbatim}
const int* cpm_ParaManager::GetDivPos( int procGrpNo=0 );
\end{verbatim}
}
指定したプロセスグループ内での領域分割位置を取得する．
\begin{description}
\item[{\tt procGrpNo[{\it input}]}] プロセスグループ番号（省略時0）
\\
\item[戻り値] 領域分割位置配列のポインタ（3wordの配列，表\ref{tbl:DirFlag}参照）
\end{description}
\end{itembox}\\
\end{spacing}


\clearpage


\subsection{全体空間の領域情報取得}
\label{globalInfo}
全体空間の領域情報取得関数は，cpm\_ParaManager.h 内で次のように定義されています．\\

\begin{spacing}{0.8}
\begin{itembox}[l]{ピッチの取得}
{\tt
\begin{verbatim}
const REAL_TYPE* cpm_ParaManager::GetPitch( int procGrpNo=0 );
\end{verbatim}
}
指定したプロセスグループ内でのVOXELピッチを取得する．
\begin{description}
\item[{\tt procGrpNo[{\it input}]}] プロセスグループ番号（省略時0）
\\
\item[戻り値] VOXELピッチ配列のポインタ（3wordの配列，表\ref{tbl:DirFlag}参照）
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{全体空間ボクセル数を取得}
{\tt
\begin{verbatim}
const int* cpm_ParaManager::GetGlobalVoxelSize( int procGrpNo=0 );
\end{verbatim}
}
指定したプロセスグループ内での全体空間のVOXEL数を取得する．
\begin{description}
\item[{\tt procGrpNo[{\it input}]}] プロセスグループ番号（省略時0）
\\
\item[戻り値]ボクセル数配列のポインタ（3wordの配列，表\ref{tbl:DirFlag}参照）
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{全体空間の原点座標を取得}
{\tt
\begin{verbatim}
const REAL_TYPE* cpm_ParaManager::GetGlobalOrigin( int procGrpNo=0 );
\end{verbatim}
}
指定したプロセスグループ内での全体空間の原点座標を取得する．
\begin{description}
\item[{\tt procGrpNo[{\it input}]}] プロセスグループ番号（省略時0）
\\
\item[戻り値]原点座標配列のポインタ（3wordの配列，表\ref{tbl:DirFlag}参照）
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{全体空間の空間サイズを取得}
{\tt
\begin{verbatim}
const REAL_TYPE* cpm_ParaManager::GetGlobalRegion( int procGrpNo=0 );
\end{verbatim}
}
指定したプロセスグループ内での全体空間の空間サイズを取得する．
\begin{description}
\item[{\tt procGrpNo[{\it input}]}] プロセスグループ番号（省略時0）
\\
\item[戻り値]空間サイズ配列のポインタ（3wordの配列，表\ref{tbl:DirFlag}参照）
\end{description}
\end{itembox}\\
\end{spacing}


\clearpage


\subsection{ローカル空間の領域情報取得}
\label{localInfo}
ローカル空間の領域情報取得関数は，cpm\_ParaManager.h 内で次のように定義されています．\\

\begin{spacing}{0.8}
\begin{itembox}[l]{自ランクのボクセル数を取得}
{\tt
\begin{verbatim}
const int* cpm_ParaManager::GetLocalVoxelSize( int procGrpNo=0 );
\end{verbatim}
}
指定したプロセスグループ内での自ランクのVOXEL数を取得する．
\begin{description}
\item[{\tt procGrpNo[{\it input}]}] プロセスグループ番号（省略時0）
\\
\item[戻り値]ボクセル数配列のポインタ（3wordの配列，表\ref{tbl:DirFlag}参照）
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{自ランクの原点座標を取得}
{\tt
\begin{verbatim}
const REAL_TYPE* cpm_ParaManager::GetLocalOrigin( int procGrpNo=0 );
\end{verbatim}
}
指定したプロセスグループ内での自ランクの原点座標を取得する．
\begin{description}
\item[{\tt procGrpNo[{\it input}]}] プロセスグループ番号（省略時0）
\\
\item[戻り値]原点座標配列のポインタ（3wordの配列，表\ref{tbl:DirFlag}参照）
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{自ランクの空間サイズを取得}
{\tt
\begin{verbatim}
const REAL_TYPE* cpm_ParaManager::GetLocalRegion( int procGrpNo=0 );
\end{verbatim}
}
指定したプロセスグループ内での自ランクの空間サイズを取得する．
\begin{description}
\item[{\tt procGrpNo[{\it input}]}] プロセスグループ番号（省略時0）
\\
\item[戻り値]空間サイズ配列のポインタ（3wordの配列，表\ref{tbl:DirFlag}参照）
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{自ランクのBCIDを取得}
{\tt
\begin{verbatim}
const int* cpm_ParaManager::GetBCID( int procGrpNo=0 );
\end{verbatim}
}
指定したプロセスグループ内での自ランクのBCIDを取得する．
\begin{description}
\item[{\tt procGrpNo[{\it input}]}] プロセスグループ番号（省略時0）
\\
\item[戻り値]BCID配列のポインタ（6wordの配列，表\ref{tbl:FaceFlag}参照）
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{自ランクの始点VOXELの全体空間でのインデクスを取得}
{\tt
\begin{verbatim}
const int* cpm_ParaManager::GetVoxelHeadIndex( int procGrpNo=0 );
\end{verbatim}
}
指定したプロセスグループ内での，自ランクの始点VOXELの全体空間でのインデクスを取得する．\\
全体空間における始点VOXELのインデクスを0としたインデクスが取得される．
\begin{description}
\item[{\tt procGrpNo[{\it input}]}] プロセスグループ番号（省略時0）
\\
\item[戻り値]始点VOXELインデクス配列のポインタ（3wordの配列，表\ref{tbl:DirFlag}参照）
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{自ランクの終点VOXELの全体空間でのインデクスを取得}
{\tt
\begin{verbatim}
const int* cpm_ParaManager::GetVoxelTailIndex( int procGrpNo=0 );
\end{verbatim}
}
指定したプロセスグループ内での，自ランクの終点VOXELの全体空間でのインデクスを取得する．\\
全体空間における始点VOXELのインデクスを0としたインデクスが取得される．
\begin{description}
\item[{\tt procGrpNo[{\it input}]}] プロセスグループ番号（省略時0）
\\
\item[戻り値]終点VOXELインデクス配列のポインタ（3wordの配列，表\ref{tbl:DirFlag}参照）
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{自ランクの隣接ランク番号を取得}
{\tt
\begin{verbatim}
const int* cpm_ParaManager::GetNeighborRankID( int procGrpNo=0 );
\end{verbatim}
}
指定したプロセスグループ内での自ランクの隣接ランク番号を取得する．\\
隣接領域が存在しない面方向には，NULLのランクがセットされている．
\begin{description}
\item[{\tt procGrpNo[{\it input}]}] プロセスグループ番号（省略時0）
\\
\item[戻り値]隣接ランク番号配列のポインタ（6wordの配列，表\ref{tbl:FaceFlag}参照）
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{ランクの周期境界位置の隣接ランク番号を取得}
{\tt
\begin{verbatim}
const int* cpm_ParaManager::GetPeriodicRankID( int procGrpNo=0 );
\end{verbatim}
}
指定したプロセスグループ内での自ランクの周期境界の隣接ランク番号を取得する．\\
内部境界および周期境界位置に隣接領域が存在しない面方向には，NULLのランクが
セットされている．
\begin{description}
\item[{\tt procGrpNo[{\it input}]}] プロセスグループ番号（省略時0）
\\
\item[戻り値]周期境界隣接ランク番号配列のポインタ（6wordの配列，表\ref{tbl:FaceFlag}参照）
\end{description}
\end{itembox}\\
\end{spacing}


\clearpage


\subsection{MPI通信関数}
\label{mpifunc}
CPMライブラリでは，プロセスグループ内での並列通信処理メソッドを提供しています．\\
プロセスグループ内での並列通信処理メソッドは，MPI関数をラップする形で実装されており，
MPI関数とほぼ同じインターフェイスで利用することができます．

また，一部のメソッドはC++のテンプレート関数として実装されており，送受信データの
MPI\_Datatypeをメソッド内部で決定しているため，ユーザーはMPI\_Datatypeを意識せずに
利用することができます．

プロセスグループ内での並列通信処理メソッドは，cpm\_ParaManager.h 内で次のように
定義されています．\\

\begin{spacing}{0.8}
\begin{itembox}[l]{MPI\_Abortのインターフェイス}
{\tt
\begin{verbatim}
void cpm_ParaManager::Abort( int errorcode );
\end{verbatim}
}
MPI\_Abortのインターフェイスメソッド．
\begin{description}
\item[{\tt errorcode[{\it input}]}] MPI\_Abortに渡すエラーコード
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{MPI\_Barrierのインターフェイス}
{\tt
\begin{verbatim}
cpm_ErrorCode cpm_ParaManager::Barrier( int procGrpNo=0 );
\end{verbatim}
}
MPI\_Barrierのインターフェイスメソッド．
\begin{description}
\item[{\tt procGrpNo[{\it input}]}] プロセスグループ番号（省略時0）
\\
\item[戻り値] エラーコード（表\ref{tbl:ErrorCode1}，\ref{tbl:ErrorCode2}を参照）
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{MPI\_Waitのインターフェイス}
{\tt
\begin{verbatim}
cpm_ErrorCode cpm_ParaManager::Wait( MPI_Request *request );
\end{verbatim}
}
MPI\_Waitのインターフェイスメソッド．
\begin{description}
\item[{\tt request[{\it input}]}] MPI\_Requestのポインタ
\\
\item[戻り値] エラーコード（表\ref{tbl:ErrorCode1}，\ref{tbl:ErrorCode2}を参照）
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{MPI\_Waitallのインターフェイス}
{\tt
\begin{verbatim}
cpm_ErrorCode cpm_ParaManager::Waitall( int count, MPI_Request requests[] );
\end{verbatim}
}
MPI\_Waitallのインターフェイスメソッド．
\begin{description}
\item[{\tt count[{\it input}]}] MPI\_Request数
\item[{\tt requests[{\it input}]}] MPI\_Requestの配列（サイズ:count）
\\
\item[戻り値] エラーコード（表\ref{tbl:ErrorCode1}，\ref{tbl:ErrorCode2}を参照）
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{MPI\_Bcastのインターフェイス}
{\tt
\begin{verbatim}
template<class T>
cpm_ErrorCode
cpm_ParaManager::Bcast( T *buf, int count, int root, int procGrpNo=0 );
\end{verbatim}
}
MPI\_Bcastのインターフェイスメソッド．
\begin{description}
\item[{\tt buf[{\it input/output}]}] 送受信バッファ
\item[{\tt count[{\it input}]}] 送受信する配列要素数
\item[{\tt root[{\it input}]}] 送信元ランク番号（procGrpNo内でのランク番号）
\item[{\tt procGrpNo[{\it input}]}] プロセスグループ番号（省略時0）
\\
\item[戻り値] エラーコード（表\ref{tbl:ErrorCode1}，\ref{tbl:ErrorCode2}を参照）
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{MPI\_Sendのインターフェイス}
{\tt
\begin{verbatim}
template<class T>
cpm_ErrorCode
cpm_ParaManager::Send( T *buf, int count, int dest, int procGrpNo=0 );
\end{verbatim}
}
MPI\_Sendのインターフェイスメソッド．
\begin{description}
\item[{\tt buf[{\it input}]}] 送信バッファ
\item[{\tt count[{\it input}]}] 送信する配列要素数
\item[{\tt dest[{\it input}]}] 送信先ランク番号（procGrpNo内でのランク番号）
\item[{\tt procGrpNo[{\it input}]}] プロセスグループ番号（省略時0）
\\
\item[戻り値] エラーコード（表\ref{tbl:ErrorCode1}，\ref{tbl:ErrorCode2}を参照）
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{MPI\_Recvのインターフェイス}
{\tt
\begin{verbatim}
template<class T>
cpm_ErrorCode
cpm_ParaManager::Recv( T *buf, int count, int source, int procGrpNo=0 );
\end{verbatim}
}
MPI\_Recvのインターフェイスメソッド．
\begin{description}
\item[{\tt buf[{\it output}]}] 受信バッファ
\item[{\tt count[{\it input}]}] 受信する配列要素数
\item[{\tt source[{\it input}]}] 送信元ランク番号（procGrpNo内でのランク番号）
\item[{\tt procGrpNo[{\it input}]}] プロセスグループ番号（省略時0）
\\
\item[戻り値] エラーコード（表\ref{tbl:ErrorCode1}，\ref{tbl:ErrorCode2}を参照）
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{MPI\_Isendのインターフェイス}
{\tt
\begin{verbatim}
template<class T>
cpm_ErrorCode
cpm_ParaManager::Isend( T *buf, int count, int dest, MPI_Request *request
                      , int procGrpNo=0 );
\end{verbatim}
}
MPI\_Isendのインターフェイスメソッド．
\begin{description}
\item[{\tt buf[{\it input}]}] 送信バッファ
\item[{\tt count[{\it input}]}] 送信する配列要素数
\item[{\tt dest[{\it input}]}] 送信先ランク番号（procGrpNo内でのランク番号）
\item[{\tt request[{\it output}]}] MPI\_Requestのポインタ
\item[{\tt procGrpNo[{\it input}]}] プロセスグループ番号（省略時0）
\\
\item[戻り値] エラーコード（表\ref{tbl:ErrorCode1}，\ref{tbl:ErrorCode2}を参照）
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{MPI\_Irecvのインターフェイス}
{\tt
\begin{verbatim}
template<class T>
cpm_ErrorCode
cpm_ParaManager::Irecv( T *buf, int count, int source, MPI_Request *request
                      , int procGrpNo=0 );
\end{verbatim}
}
MPI\_Irecvのインターフェイスメソッド．
\begin{description}
\item[{\tt buf[{\it output}]}] 受信バッファ
\item[{\tt count[{\it input}]}] 受信する配列要素数
\item[{\tt source[{\it input}]}] 送信元ランク番号（procGrpNo内でのランク番号）
\item[{\tt request[{\it output}]}] MPI\_Requestのポインタ
\item[{\tt procGrpNo[{\it input}]}] プロセスグループ番号（省略時0）
\\
\item[戻り値] エラーコード（表\ref{tbl:ErrorCode1}，\ref{tbl:ErrorCode2}を参照）
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{MPI\_Allreduceのインターフェイス}
{\tt
\begin{verbatim}
template<class T>
cpm_ErrorCode
cpm_ParaManager::Allreduce( T *sendbuf, T *recvbuf, int count, MPI_Op op
                          , int procGrpNo=0 );
\end{verbatim}
}
MPI\_Allreduceのインターフェイスメソッド．
\begin{description}
\item[{\tt sendbuf[{\it input}]}] 送信バッファ
\item[{\tt recvbuf[{\it output}]}] 受信バッファ
\item[{\tt count[{\it input}]}] 送受信する配列要素数
\item[{\tt op[{\it input}]}] オペレータ（MPI\_Op）
\item[{\tt procGrpNo[{\it input}]}] プロセスグループ番号（省略時0）
\\
\item[戻り値] エラーコード（表\ref{tbl:ErrorCode1}，\ref{tbl:ErrorCode2}を参照）
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{MPI\_Gatherのインターフェイス}
{\tt
\begin{verbatim}
template<class Ts, class Tr>
cpm_ErrorCode cpm_ParaManager::Gather( Ts *sendbuf, int sendcnt
                                     , Tr *recvbuf, int recvcnt
                                     , int root, int procGrpNo=0 );
\end{verbatim}
}
MPI\_Gatherのインターフェイスメソッド．
\begin{description}
\item[{\tt sendbuf[{\it input}]}] 送信バッファ
\item[{\tt sendcnt[{\it input}]}] 送信バッファの配列要素数
\item[{\tt recvbuf[{\it output}]}] 受信バッファ
\item[{\tt recvcnt[{\it input}]}] 受信バッファの配列要素数
\item[{\tt root[{\it input}]}] 受信するランク番号（procGrpNo内でのランク番号）
\item[{\tt procGrpNo[{\it input}]}] プロセスグループ番号（省略時0）
\\
\item[戻り値] エラーコード（表\ref{tbl:ErrorCode1}，\ref{tbl:ErrorCode2}を参照）
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{MPI\_Allgatherのインターフェイス}
{\tt
\begin{verbatim}
template<class Ts, class Tr>
cpm_ErrorCode cpm_ParaManager::Allgather( Ts *sendbuf, int sendcnt
                                        , Tr *recvbuf, int recvcnt
                                        , int procGrpNo=0 );
\end{verbatim}
}
MPI\_Allgatherのインターフェイスメソッド．
\begin{description}
\item[{\tt sendbuf[{\it input}]}] 送信バッファ
\item[{\tt sendcnt[{\it input}]}] 送信バッファの配列要素数
\item[{\tt recvbuf[{\it output}]}] 受信バッファ
\item[{\tt recvcnt[{\it input}]}] 受信バッファの配列要素数
\item[{\tt procGrpNo[{\it input}]}] プロセスグループ番号（省略時0）
\\
\item[戻り値] エラーコード（表\ref{tbl:ErrorCode1}，\ref{tbl:ErrorCode2}を参照）
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{MPI\_Gathervのインターフェイス}
{\tt
\begin{verbatim}
template<class Ts, class Tr>
cpm_ErrorCode cpm_ParaManager::Gatherv( Ts *sendbuf, int sendcnt
                                      , Tr *recvbuf, int *recvcnts
                                      , int *displs, int root
                                      , int procGrpNo=0 );
\end{verbatim}
}
MPI\_Gathervのインターフェイスメソッド．
\begin{description}
\item[{\tt sendbuf[{\it input}]}] 送信バッファ
\item[{\tt sendcnt[{\it input}]}] 送信バッファの配列要素数
\item[{\tt recvbuf[{\it output}]}] 受信バッファ
\item[{\tt recvcnts[{\it input}]}] 各ランクからの受信データサイズ
\item[{\tt displs[{\it input}]}] 各ランクからの受信データ配置位置
\item[{\tt root[{\it input}]}] 受信するランク番号（procGrpNo内でのランク番号）
\item[{\tt procGrpNo[{\it input}]}] プロセスグループ番号（省略時0）
\\
\item[戻り値] エラーコード（表\ref{tbl:ErrorCode1}，\ref{tbl:ErrorCode2}を参照）
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{MPI\_Allgathervのインターフェイス}
{\tt
\begin{verbatim}
template<class Ts, class Tr>
cpm_ErrorCode cpm_ParaManager::Allgatherv( Ts *sendbuf, int sendcnt
                                         , Tr *recvbuf, int *recvcnts
                                         , int *displs, int procGrpNo=0 );
\end{verbatim}
}
MPI\_Allgathervのインターフェイスメソッド．
\begin{description}
\item[{\tt sendbuf[{\it input}]}] 送信バッファ
\item[{\tt sendcnt[{\it input}]}] 送信バッファの配列要素数
\item[{\tt recvbuf[{\it output}]}] 受信バッファ
\item[{\tt recvcnts[{\it input}]}] 各ランクからの受信データサイズ
\item[{\tt displs[{\it input}]}] 各ランクからの受信データ配置位置
\item[{\tt procGrpNo[{\it input}]}] プロセスグループ番号（省略時0）
\\
\item[戻り値] エラーコード（表\ref{tbl:ErrorCode1}，\ref{tbl:ErrorCode2}を参照）
\end{description}
\end{itembox}\\
\end{spacing}


\clearpage


\subsection{内部境界袖通信メソッド}
\label{bndcomm}
CPMライブラリでは，領域分割空間での隣接領域間（内部境界）の袖領域の通信メソッドを
提供しています．袖領域の通信メソッドは，配列形状毎に用意されています．

また，C++のテンプレート関数として実装されており，送受信データのMPI\_Datatypeを
メソッド内部で決定しているため，ユーザーはMPI\_Datatypeを意識せずに利用することが
できます．

袖領域の通信メソッドは，cpm\_ParaManager.h 内で次のように定義されています．\\

\begin{spacing}{0.8}
\begin{itembox}[l]{袖通信バッファのセット}
{\tt
\begin{verbatim}
cpm_ErrorCode
cpm_ParaManager::SetBndCommBuffer( size_t maxVC, size_t maxN
                                 , int procGrpNo=0 );
\end{verbatim}
}
袖通信で使用する転送データ格納用バッファの確保を行う．\\
VoxelInit（\ref{voxelInit}章を参照）実行時にも実行されるが，プログラムの途中で
バッファサイズを変更したい場合に呼び出す．
\begin{description}
\item[{\tt maxVC[{\it input}]}] 袖通信バッファ確保用の最大袖層数
\item[{\tt maxN[{\it input}]}] 袖通信バッファ確保用の最大成分数
\item[{\tt procGrpNo[{\it input}]}] バッファを確保するプロセスグループの番号（省略時0）
\\
\item[戻り値] エラーコード（表\ref{tbl:ErrorCode1}，\ref{tbl:ErrorCode2}を参照）
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{袖通信バッファサイズの取得}
{\tt
\begin{verbatim}
size_t cpm_ParaManager::GetBndCommBufferSize( int procGrpNo=0 );
\end{verbatim}
}
袖通信で使用する転送データ格納用バッファの確保済みサイズを取得する．
\begin{description}
\item[{\tt procGrpNo[{\it input}]}] バッファサイズを取得するプロセスグループの番号（省略時0）
\\
\item[戻り値] 確保済みのバッファサイズ（byte）
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{袖通信(Scalar3D版)}
{\tt
\begin{verbatim}
template<class T>
cpm_ErrorCode
cpm_ParaManager::BndCommS3D( T *array, int imax, int jmax, int kmax
                           , int vc, int vc_comm, int procGrpNo=0 );
\end{verbatim}
}
Scalar3D形状の配列の内部境界袖通信を行う．\\
VOXEL数が[imax,jmax,kmax]の領域に対して，配列形状がarray(imax,jmax,kmax)の
Fortran型の配列の袖通信を行う．
\begin{description}
\item[{\tt array[{\it input/output}]}] 袖通信をする配列の先頭ポインタ
\item[{\tt imax[{\it input}]}] 配列サイズ(I方向)
\item[{\tt jmax[{\it input}]}] 配列サイズ(J方向)
\item[{\tt kmax[{\it input}]}] 配列サイズ(K方向)
\item[{\tt vc[{\it input}]}] 仮想セル数
\item[{\tt vc\_comm[{\it input}]}] 袖通信を行う仮想セル数
\item[{\tt procGrpNo[{\it input}]}] プロセスグループ番号（省略時0）
\\
\item[戻り値] エラーコード（表\ref{tbl:ErrorCode1}，\ref{tbl:ErrorCode2}を参照）
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{袖通信(Vector3D版)}
{\tt
\begin{verbatim}
template<class T>
cpm_ErrorCode
cpm_ParaManager::BndCommV3D( T *array, int imax, int jmax, int kmax
                           , int vc, int vc_comm, int procGrpNo=0 );
\end{verbatim}
}
Vector3D形状の配列の内部境界袖通信を行う．\\
VOXEL数が[imax,jmax,kmax]の領域に対して，配列形状がarray(imax,jmax,kmax,3)の
Fortran型の配列の袖通信を行う．（成分数=3）
\begin{description}
\item[{\tt array[{\it input/output}]}] 袖通信をする配列の先頭ポインタ
\item[{\tt imax[{\it input}]}] 配列サイズ(I方向)
\item[{\tt jmax[{\it input}]}] 配列サイズ(J方向)
\item[{\tt kmax[{\it input}]}] 配列サイズ(K方向)
\item[{\tt vc[{\it input}]}] 仮想セル数
\item[{\tt vc\_comm[{\it input}]}] 袖通信を行う仮想セル数
\item[{\tt procGrpNo[{\it input}]}] プロセスグループ番号（省略時0）
\\
\item[戻り値] エラーコード（表\ref{tbl:ErrorCode1}，\ref{tbl:ErrorCode2}を参照）
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{袖通信(Scalar4D版)}
{\tt
\begin{verbatim}
template<class T>
cpm_ErrorCode
cpm_ParaManager::BndCommS4D( T *array, int imax, int jmax, int kmax
                           , int nmax, int vc, int vc_comm
                           , int procGrpNo=0 );
\end{verbatim}
}
Scalar4D形状の配列の内部境界袖通信を行う．\\
VOXEL数が[imax,jmax,kmax]の領域に対して，配列形状がarray(imax,jmax,kmax,nmax)の
Fortran型の配列の袖通信を行う．（成分数=nmax）
\begin{description}
\item[{\tt array[{\it input/output}]}] 袖通信をする配列の先頭ポインタ
\item[{\tt imax[{\it input}]}] 配列サイズ(I方向)
\item[{\tt jmax[{\it input}]}] 配列サイズ(J方向)
\item[{\tt kmax[{\it input}]}] 配列サイズ(K方向)
\item[{\tt nmax[{\it input}]}] 成分数
\item[{\tt vc[{\it input}]}] 仮想セル数
\item[{\tt vc\_comm[{\it input}]}] 袖通信を行う仮想セル数
\item[{\tt procGrpNo[{\it input}]}] プロセスグループ番号（省略時0）
\\
\item[戻り値] エラーコード（表\ref{tbl:ErrorCode1}，\ref{tbl:ErrorCode2}を参照）
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{袖通信(Vector3DEx版)}
{\tt
\begin{verbatim}
template<class T>
cpm_ErrorCode
cpm_ParaManager::BndCommV3DEx( T *array, int imax, int jmax, int kmax
                             , int vc, int vc_comm, int procGrpNo=0 );
\end{verbatim}
}
Vector3DEx形状の配列の内部境界袖通信を行う．\\
VOXEL数が[imax,jmax,kmax]の領域に対して，配列形状がarray(3,imax,jmax,kmax)の
Fortran型の配列の袖通信を行う．（成分数=3）
\begin{description}
\item[{\tt array[{\it input/output}]}] 袖通信をする配列の先頭ポインタ
\item[{\tt imax[{\it input}]}] 配列サイズ(I方向)
\item[{\tt jmax[{\it input}]}] 配列サイズ(J方向)
\item[{\tt kmax[{\it input}]}] 配列サイズ(K方向)
\item[{\tt vc[{\it input}]}] 仮想セル数
\item[{\tt vc\_comm[{\it input}]}] 袖通信を行う仮想セル数
\item[{\tt procGrpNo[{\it input}]}] プロセスグループ番号（省略時0）
\\
\item[戻り値] エラーコード（表\ref{tbl:ErrorCode1}，\ref{tbl:ErrorCode2}を参照）
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{袖通信(Scalar4DEx版)}
{\tt
\begin{verbatim}
template<class T>
cpm_ErrorCode
cpm_ParaManager::BndCommS4DEx( T *array, int nmax
                             , int imax, int jmax, int kmax
                             , int vc, int vc_comm, int procGrpNo=0 );
\end{verbatim}
}
Scalar4DEx形状の配列の内部境界袖通信を行う．\\
VOXEL数が[imax,jmax,kmax]の領域に対して，配列形状がarray(nmax,imax,jmax,kmax)の
Fortran型の配列の袖通信を行う．（成分数=nmax）
\begin{description}
\item[{\tt array[{\it input/output}]}] 袖通信をする配列の先頭ポインタ
\item[{\tt nmax[{\it input}]}] 成分数
\item[{\tt imax[{\it input}]}] 配列サイズ(I方向)
\item[{\tt jmax[{\it input}]}] 配列サイズ(J方向)
\item[{\tt kmax[{\it input}]}] 配列サイズ(K方向)
\item[{\tt vc[{\it input}]}] 仮想セル数
\item[{\tt vc\_comm[{\it input}]}] 袖通信を行う仮想セル数
\item[{\tt procGrpNo[{\it input}]}] プロセスグループ番号（省略時0）
\\
\item[戻り値] エラーコード（表\ref{tbl:ErrorCode1}，\ref{tbl:ErrorCode2}を参照）
\end{description}
\end{itembox}\\
\end{spacing}


\clearpage


\subsection{内部境界袖通信メソッド（非同期版）}
\label{Hbndcomm}
非同期版の内部境界袖通信メソッドは，送信データのパックと非同期送受信処理をするメソッドと，
通信完了の待機と受信データの展開をするメソッドに分かれており，非同期通信中に他の
計算処理を実行することが可能です．

非同期版の袖領域通信メソッドは，cpm\_ParaManager.h 内で次のように定義されています．\\

\begin{spacing}{0.8}
\begin{itembox}[l]{非同期袖通信(Scalar3D版)}
{\tt
\begin{verbatim}
template<class T>
cpm_ErrorCode
cpm_ParaManager::BndCommS3D_nowait( T *array, int imax, int jmax, int kmax
                                  , int vc, int vc_comm
                                  , MPI_Request req[12], int procGrpNo=0 );
\end{verbatim}
}
Scalar3D形状の配列の内部境界袖通信を行う．\\
VOXEL数が[imax,jmax,kmax]の領域に対して，配列形状がarray(imax,jmax,kmax)の
Fortran型の配列の袖通信を行う．\\
通信完了待ちと受信データの展開は行わない．
\begin{description}
\item[{\tt array[{\it input}]}] 袖通信をする配列の先頭ポインタ
\item[{\tt imax[{\it input}]}] 配列サイズ(I方向)
\item[{\tt jmax[{\it input}]}] 配列サイズ(J方向)
\item[{\tt kmax[{\it input}]}] 配列サイズ(K方向)
\item[{\tt vc[{\it input}]}] 仮想セル数
\item[{\tt vc\_comm[{\it input}]}] 袖通信を行う仮想セル数
\item[{\tt req[{\it output}]}] MPI\_Request配列（サイズ12）
\item[{\tt procGrpNo[{\it input}]}] プロセスグループ番号（省略時0）
\\
\item[戻り値] エラーコード（表\ref{tbl:ErrorCode1}，\ref{tbl:ErrorCode2}を参照）
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{非同期袖通信(Scalar3D版)の待機，展開処理}
{\tt
\begin{verbatim}
template<class T>
cpm_ErrorCode
cpm_ParaManager::wait_BndCommS3D( T *array, int imax, int jmax, int kmax
                                , int vc, int vc_comm
                                , MPI_Request req[12], int procGrpNo=0 );
\end{verbatim}
}
BndCommS3D\_nowaitメソッドの通信完了待ちと受信データの展開を行う．
\begin{description}
\item[{\tt array[{\it input/output}]}] 袖通信をする配列の先頭ポインタ
\item[{\tt imax[{\it input}]}] 配列サイズ(I方向)
\item[{\tt jmax[{\it input}]}] 配列サイズ(J方向)
\item[{\tt kmax[{\it input}]}] 配列サイズ(K方向)
\item[{\tt vc[{\it input}]}] 仮想セル数
\item[{\tt vc\_comm[{\it input}]}] 袖通信を行う仮想セル数
\item[{\tt req[{\it input}]}] MPI\_Request配列（サイズ12）
\item[{\tt procGrpNo[{\it input}]}] プロセスグループ番号（省略時0）
\\
\item[戻り値] エラーコード（表\ref{tbl:ErrorCode1}，\ref{tbl:ErrorCode2}を参照）
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{非同期袖通信(Vector3D版)}
{\tt
\begin{verbatim}
template<class T>
cpm_ErrorCode
cpm_ParaManager::BndCommV3D_nowait( T *array, int imax, int jmax, int kmax
                                  , int vc, int vc_comm
                                  , MPI_Request req[12], int procGrpNo=0 );
\end{verbatim}
}
Vector3D形状の配列の内部境界袖通信を行う．\\
VOXEL数が[imax,jmax,kmax]の領域に対して，配列形状がarray(imax,jmax,kmax,3)の
Fortran型の配列の袖通信を行う．（成分数=3）\\
通信完了待ちと受信データの展開は行わない．
\begin{description}
\item[{\tt array[{\it input}]}] 袖通信をする配列の先頭ポインタ
\item[{\tt imax[{\it input}]}] 配列サイズ(I方向)
\item[{\tt jmax[{\it input}]}] 配列サイズ(J方向)
\item[{\tt kmax[{\it input}]}] 配列サイズ(K方向)
\item[{\tt vc[{\it input}]}] 仮想セル数
\item[{\tt vc\_comm[{\it input}]}] 袖通信を行う仮想セル数
\item[{\tt req[{\it output}]}] MPI\_Request配列（サイズ12）
\item[{\tt procGrpNo[{\it input}]}] プロセスグループ番号（省略時0）
\\
\item[戻り値] エラーコード（表\ref{tbl:ErrorCode1}，\ref{tbl:ErrorCode2}を参照）
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{非同期袖通信(Vector3D版)の待機，展開処理}
{\tt
\begin{verbatim}
template<class T>
cpm_ErrorCode
cpm_ParaManager::wait_BndCommV3D( T *array, int imax, int jmax, int kmax
                                , int vc, int vc_comm
                                , MPI_Request req[12], int procGrpNo=0 );
\end{verbatim}
}
BndCommV3D\_nowaitメソッドの通信完了待ちと受信データの展開を行う．
\begin{description}
\item[{\tt array[{\it input/output}]}] 袖通信をする配列の先頭ポインタ
\item[{\tt imax[{\it input}]}] 配列サイズ(I方向)
\item[{\tt jmax[{\it input}]}] 配列サイズ(J方向)
\item[{\tt kmax[{\it input}]}] 配列サイズ(K方向)
\item[{\tt vc[{\it input}]}] 仮想セル数
\item[{\tt vc\_comm[{\it input}]}] 袖通信を行う仮想セル数
\item[{\tt req[{\it input}]}] MPI\_Request配列（サイズ12）
\item[{\tt procGrpNo[{\it input}]}] プロセスグループ番号（省略時0）
\\
\item[戻り値] エラーコード（表\ref{tbl:ErrorCode1}，\ref{tbl:ErrorCode2}を参照）
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{非同期袖通信(Scalar4D版)}
{\tt
\begin{verbatim}
template<class T>
cpm_ErrorCode
cpm_ParaManager::BndCommS4D_nowait( T *array, int imax, int jmax, int kmax
                                  , int nmax, int vc, int vc_comm
                                  , MPI_Request req[12]
                                  , int procGrpNo=0 );
\end{verbatim}
}
Scalar4D形状の配列の内部境界袖通信を行う．\\
VOXEL数が[imax,jmax,kmax]の領域に対して，配列形状がarray(imax,jmax,kmax,nmax)の
Fortran型の配列の袖通信を行う．（成分数=nmax）\\
通信完了待ちと受信データの展開は行わない．
\begin{description}
\item[{\tt array[{\it input}]}] 袖通信をする配列の先頭ポインタ
\item[{\tt imax[{\it input}]}] 配列サイズ(I方向)
\item[{\tt jmax[{\it input}]}] 配列サイズ(J方向)
\item[{\tt kmax[{\it input}]}] 配列サイズ(K方向)
\item[{\tt nmax[{\it input}]}] 成分数
\item[{\tt vc[{\it input}]}] 仮想セル数
\item[{\tt vc\_comm[{\it input}]}] 袖通信を行う仮想セル数
\item[{\tt req[{\it output}]}] MPI\_Request配列（サイズ12）
\item[{\tt procGrpNo[{\it input}]}] プロセスグループ番号（省略時0）
\\
\item[戻り値] エラーコード（表\ref{tbl:ErrorCode1}，\ref{tbl:ErrorCode2}を参照）
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{非同期袖通信(Scalar4D版)の待機，展開処理}
{\tt
\begin{verbatim}
template<class T>
cpm_ErrorCode
cpm_ParaManager::wait_BndCommS4D( T *array
                                , int imax, int jmax, int kmax, int nmax
                                , int vc, int vc_comm
                                , MPI_Request req[12], int procGrpNo=0 );
\end{verbatim}
}
BndCommS4D\_nowaitメソッドの通信完了待ちと受信データの展開を行う．
\begin{description}
\item[{\tt array[{\it input/output}]}] 袖通信をする配列の先頭ポインタ
\item[{\tt imax[{\it input}]}] 配列サイズ(I方向)
\item[{\tt jmax[{\it input}]}] 配列サイズ(J方向)
\item[{\tt kmax[{\it input}]}] 配列サイズ(K方向)
\item[{\tt nmax[{\it input}]}] 成分数
\item[{\tt vc[{\it input}]}] 仮想セル数
\item[{\tt vc\_comm[{\it input}]}] 袖通信を行う仮想セル数
\item[{\tt req[{\it input}]}] MPI\_Request配列（サイズ12）
\item[{\tt procGrpNo[{\it input}]}] プロセスグループ番号（省略時0）
\\
\item[戻り値] エラーコード（表\ref{tbl:ErrorCode1}，\ref{tbl:ErrorCode2}を参照）
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{非同期袖通信(Vector3DEx版)}
{\tt
\begin{verbatim}
template<class T>
cpm_ErrorCode
cpm_ParaManager::BndCommV3DEx_nowait( T *array
                                  , int imax, int jmax, int kmax
                                  , int vc, int vc_comm
                                  , MPI_Request req[12], int procGrpNo=0 );
\end{verbatim}
}
Vector3DEx形状の配列の内部境界袖通信を行う．\\
VOXEL数が[imax,jmax,kmax]の領域に対して，配列形状がarray(3,imax,jmax,kmax)の
Fortran型の配列の袖通信を行う．（成分数=3）\\
通信完了待ちと受信データの展開は行わない．
\begin{description}
\item[{\tt array[{\it input/output}]}] 袖通信をする配列の先頭ポインタ
\item[{\tt imax[{\it input}]}] 配列サイズ(I方向)
\item[{\tt jmax[{\it input}]}] 配列サイズ(J方向)
\item[{\tt kmax[{\it input}]}] 配列サイズ(K方向)
\item[{\tt vc[{\it input}]}] 仮想セル数
\item[{\tt vc\_comm[{\it input}]}] 袖通信を行う仮想セル数
\item[{\tt req[{\it input}]}] MPI\_Request配列（サイズ12）
\item[{\tt procGrpNo[{\it input}]}] プロセスグループ番号（省略時0）
\\
\item[戻り値] エラーコード（表\ref{tbl:ErrorCode1}，\ref{tbl:ErrorCode2}を参照）
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{非同期袖通信(Vector3DEx版)の待機，展開処理}
{\tt
\begin{verbatim}
template<class T>
cpm_ErrorCode
cpm_ParaManager::wait_BndCommV3DEx( T *array
                                  , int imax, int jmax, int kmax
                                  , int vc, int vc_comm
                                  , MPI_Request req[12], int procGrpNo=0 );
\end{verbatim}
}
BndCommV3DEx\_nowaitメソッドの通信完了待ちと受信データの展開を行う．
\begin{description}
\item[{\tt array[{\it input/output}]}] 袖通信をする配列の先頭ポインタ
\item[{\tt imax[{\it input}]}] 配列サイズ(I方向)
\item[{\tt jmax[{\it input}]}] 配列サイズ(J方向)
\item[{\tt kmax[{\it input}]}] 配列サイズ(K方向)
\item[{\tt vc[{\it input}]}] 仮想セル数
\item[{\tt vc\_comm[{\it input}]}] 袖通信を行う仮想セル数
\item[{\tt req[{\it input}]}] MPI\_Request配列（サイズ12）
\item[{\tt procGrpNo[{\it input}]}] プロセスグループ番号（省略時0）
\\
\item[戻り値] エラーコード（表\ref{tbl:ErrorCode1}，\ref{tbl:ErrorCode2}を参照）
\end{description}
\end{itembox}\\
\end{spacing}


\begin{spacing}{0.8}
\begin{itembox}[l]{非同期袖通信(Scalar4DEx版)}
{\tt
\begin{verbatim}
template<class T>
cpm_ErrorCode
cpm_ParaManager::BndCommS4DEx_nowait( T *array
                                  , int nmax, int imax, int jmax, int kmax
                                  , int vc, int vc_comm
                                  , MPI_Request req[12], int procGrpNo=0 );
\end{verbatim}
}
Scalar4DEx形状の配列の内部境界袖通信を行う．\\
VOXEL数が[imax,jmax,kmax]の領域に対して，配列形状がarray(nmax,imax,jmax,kmax)の
Fortran型の配列の袖通信を行う．（成分数=nmax）\\
通信完了待ちと受信データの展開は行わない．
\begin{description}
\item[{\tt array[{\it input/output}]}] 袖通信をする配列の先頭ポインタ
\item[{\tt nmax[{\it input}]}] 成分数
\item[{\tt imax[{\it input}]}] 配列サイズ(I方向)
\item[{\tt jmax[{\it input}]}] 配列サイズ(J方向)
\item[{\tt kmax[{\it input}]}] 配列サイズ(K方向)
\item[{\tt vc[{\it input}]}] 仮想セル数
\item[{\tt vc\_comm[{\it input}]}] 袖通信を行う仮想セル数
\item[{\tt req[{\it output}]}] MPI\_Request配列（サイズ12）
\item[{\tt procGrpNo[{\it input}]}] プロセスグループ番号（省略時0）
\\
\item[戻り値] エラーコード（表\ref{tbl:ErrorCode1}，\ref{tbl:ErrorCode2}を参照）
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{非同期袖通信(Scalar4DEx版)の待機，展開処理}
{\tt
\begin{verbatim}
template<class T>
cpm_ErrorCode
cpm_ParaManager::wait_BndCommS4DEx( T *array
                                  , int nmax, int imax, int jmax, int kmax
                                  , int vc, int vc_comm
                                  , MPI_Request req[12], int procGrpNo=0 );
\end{verbatim}
}
BndCommS4DEx\_nowaitメソッドの通信完了待ちと受信データの展開を行う．
\begin{description}
\item[{\tt array[{\it input/output}]}] 袖通信をする配列の先頭ポインタ
\item[{\tt nmax[{\it input}]}] 成分数
\item[{\tt imax[{\it input}]}] 配列サイズ(I方向)
\item[{\tt jmax[{\it input}]}] 配列サイズ(J方向)
\item[{\tt kmax[{\it input}]}] 配列サイズ(K方向)
\item[{\tt vc[{\it input}]}] 仮想セル数
\item[{\tt vc\_comm[{\it input}]}] 袖通信を行う仮想セル数
\item[{\tt req[{\it input}]}] MPI\_Request配列（サイズ12）
\item[{\tt procGrpNo[{\it input}]}] プロセスグループ番号（省略時0）
\\
\item[戻り値] エラーコード（表\ref{tbl:ErrorCode1}，\ref{tbl:ErrorCode2}を参照）
\end{description}
\end{itembox}\\
\end{spacing}


\clearpage


\subsection{周期境界袖通信メソッド}
\label{pericomm}
CPMライブラリでは，領域分割空間での周期境界（外部境界）の袖領域の通信メソッドを
提供しています．袖領域の通信メソッドは，配列形状毎に用意されています．

また，C++のテンプレート関数として実装されており，送受信データのMPI\_Datatypeを
メソッド内部で決定しているため，ユーザーはMPI\_Datatypeを意識せずに利用することが
できます．

周期境界の袖通信メソッドは，cpm\_ParaManager.h 内で次のように定義されています．

\begin{spacing}{0.8}
\begin{itembox}[l]{周期境界袖通信(Scalar3D版)}
{\tt
\begin{verbatim}
template<class T>
cpm_ErrorCode
cpm_ParaManager::PeriodicCommS3D( T *array
                                , int imax, int jmax, int kmax
                                , int vc, int vc_comm
                                , cpm_DirFlag dir, cpm_PMFlag pm
                                , int procGrpNo=0 );
\end{verbatim}
}
Scalar3D形状の配列の周期境界袖通信を行う．\\
VOXEL数が[imax,jmax,kmax]の領域に対して，配列形状がarray(imax,jmax,kmax)の
Fortran型の配列の袖通信を行う．
\begin{description}
\item[{\tt array[{\it input/output}]}] 袖通信をする配列の先頭ポインタ
\item[{\tt imax[{\it input}]}] 配列サイズ(I方向)
\item[{\tt jmax[{\it input}]}] 配列サイズ(J方向)
\item[{\tt kmax[{\it input}]}] 配列サイズ(K方向)
\item[{\tt vc[{\it input}]}] 仮想セル数
\item[{\tt vc\_comm[{\it input}]}] 袖通信を行う仮想セル数
\item[{\tt dir[{\it input}]}] 袖通信を行う軸方向フラグ（表\ref{tbl:DirFlag}を参照）
\item[{\tt pm[{\it input}]}] 袖通信を行う正負方向フラグ（表\ref{tbl:PMFlag}を参照）
\item[{\tt procGrpNo[{\it input}]}] プロセスグループ番号（省略時0）
\\
\item[戻り値] エラーコード（表\ref{tbl:ErrorCode1}，\ref{tbl:ErrorCode2}を参照）
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{周期境界袖通信(Vector3D版)}
{\tt
\begin{verbatim}
template<class T>
cpm_ErrorCode
cpm_ParaManager::PeriodicCommV3D( T *array
                                , int imax, int jmax, int kmax
                                , int vc, int vc_comm
                                , cpm_DirFlag dir, cpm_PMFlag pm
                                , int procGrpNo=0 );
\end{verbatim}
}
Vector3D形状の配列の周期境界袖通信を行う．\\
VOXEL数が[imax,jmax,kmax]の領域に対して，配列形状がarray(imax,jmax,kmax,3)の
Fortran型の配列の袖通信を行う（成分数=3）．
\begin{description}
\item[{\tt array[{\it input/output}]}] 袖通信をする配列の先頭ポインタ
\item[{\tt imax[{\it input}]}] 配列サイズ(I方向)
\item[{\tt jmax[{\it input}]}] 配列サイズ(J方向)
\item[{\tt kmax[{\it input}]}] 配列サイズ(K方向)
\item[{\tt vc[{\it input}]}] 仮想セル数
\item[{\tt vc\_comm[{\it input}]}] 袖通信を行う仮想セル数
\item[{\tt dir[{\it input}]}] 袖通信を行う軸方向フラグ（表\ref{tbl:DirFlag}を参照）
\item[{\tt pm[{\it input}]}] 袖通信を行う正負方向フラグ（表\ref{tbl:PMFlag}を参照）
\item[{\tt procGrpNo[{\it input}]}] プロセスグループ番号（省略時0）
\\
\item[戻り値] エラーコード（表\ref{tbl:ErrorCode1}，\ref{tbl:ErrorCode2}を参照）
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{周期境界袖通信(Scalar4D版)}
{\tt
\begin{verbatim}
template<class T>
cpm_ErrorCode
cpm_ParaManager::PeriodicCommS4D( T *array
                                , int imax, int jmax, int kmax, int nmax
                                , int vc, int vc_comm
                                , cpm_DirFlag dir, cpm_PMFlag pm
                                , int procGrpNo=0 );
\end{verbatim}
}
Scalar4D形状の配列の周期境界袖通信を行う．\\
VOXEL数が[imax,jmax,kmax]の領域に対して，配列形状がarray(imax,jmax,kmax,nmax)の
Fortran型の配列の袖通信を行う（成分数=nmax）．
\begin{description}
\item[{\tt array[{\it input/output}]}] 袖通信をする配列の先頭ポインタ
\item[{\tt imax[{\it input}]}] 配列サイズ(I方向)
\item[{\tt jmax[{\it input}]}] 配列サイズ(J方向)
\item[{\tt kmax[{\it input}]}] 配列サイズ(K方向)
\item[{\tt nmax[{\it input}]}] 成分数
\item[{\tt vc[{\it input}]}] 仮想セル数
\item[{\tt vc\_comm[{\it input}]}] 袖通信を行う仮想セル数
\item[{\tt dir[{\it input}]}] 袖通信を行う軸方向フラグ（表\ref{tbl:DirFlag}を参照）
\item[{\tt pm[{\it input}]}] 袖通信を行う正負方向フラグ（表\ref{tbl:PMFlag}を参照）
\item[{\tt procGrpNo[{\it input}]}] プロセスグループ番号（省略時0）
\\
\item[戻り値] エラーコード（表\ref{tbl:ErrorCode1}，\ref{tbl:ErrorCode2}を参照）
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{周期境界袖通信(Vector3DEx版)}
{\tt
\begin{verbatim}
template<class T>
cpm_ErrorCode
cpm_ParaManager::PeriodicCommV3DEx( T *array
                                  , int imax, int jmax, int kmax
                                  , int vc, int vc_comm
                                  , cpm_DirFlag dir, cpm_PMFlag pm
                                  , int procGrpNo=0 );
\end{verbatim}
}
Vector3DEx形状の配列の周期境界袖通信を行う．\\
VOXEL数が[imax,jmax,kmax]の領域に対して，配列形状がarray(3,imax,jmax,kmax)の
Fortran型の配列の袖通信を行う（成分数=3）．
\begin{description}
\item[{\tt array[{\it input/output}]}] 袖通信をする配列の先頭ポインタ
\item[{\tt imax[{\it input}]}] 配列サイズ(I方向)
\item[{\tt jmax[{\it input}]}] 配列サイズ(J方向)
\item[{\tt kmax[{\it input}]}] 配列サイズ(K方向)
\item[{\tt vc[{\it input}]}] 仮想セル数
\item[{\tt vc\_comm[{\it input}]}] 袖通信を行う仮想セル数
\item[{\tt dir[{\it input}]}] 袖通信を行う軸方向フラグ（表\ref{tbl:DirFlag}を参照）
\item[{\tt pm[{\it input}]}] 袖通信を行う正負方向フラグ（表\ref{tbl:PMFlag}を参照）
\item[{\tt procGrpNo[{\it input}]}] プロセスグループ番号（省略時0）
\\
\item[戻り値] エラーコード（表\ref{tbl:ErrorCode1}，\ref{tbl:ErrorCode2}を参照）
\end{description}
\end{itembox}\\
\end{spacing}

\begin{spacing}{0.8}
\begin{itembox}[l]{周期境界袖通信(Scalar4DEx版)}
{\tt
\begin{verbatim}
template<class T>
cpm_ErrorCode
cpm_ParaManager::PeriodicCommS4DEx( T *array
                                  , int nmax, int imax, int jmax, int kmax
                                  , int vc, int vc_comm
                                  , cpm_DirFlag dir, cpm_PMFlag pm
                                  , int procGrpNo=0 );
\end{verbatim}
}
Scalar4DEx形状の配列の周期境界袖通信を行う．\\
VOXEL数が[imax,jmax,kmax]の領域に対して，配列形状がarray(nmax,imax,jmax,kmax)の
Fortran型の配列の袖通信を行う（成分数=nmax）．
\begin{description}
\item[{\tt array[{\it input/output}]}] 袖通信をする配列の先頭ポインタ
\item[{\tt nmax[{\it input}]}] 成分数
\item[{\tt imax[{\it input}]}] 配列サイズ(I方向)
\item[{\tt jmax[{\it input}]}] 配列サイズ(J方向)
\item[{\tt kmax[{\it input}]}] 配列サイズ(K方向)
\item[{\tt vc[{\it input}]}] 仮想セル数
\item[{\tt vc\_comm[{\it input}]}] 袖通信を行う仮想セル数
\item[{\tt dir[{\it input}]}] 袖通信を行う軸方向フラグ（表\ref{tbl:DirFlag}を参照）
\item[{\tt pm[{\it input}]}] 袖通信を行う正負方向フラグ（表\ref{tbl:PMFlag}を参照）
\item[{\tt procGrpNo[{\it input}]}] プロセスグループ番号（省略時0）
\\
\item[戻り値] エラーコード（表\ref{tbl:ErrorCode1}，\ref{tbl:ErrorCode2}を参照）
\end{description}
\end{itembox}\\
\end{spacing}
